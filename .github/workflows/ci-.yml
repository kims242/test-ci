name: CI Docker Node Postgres

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
    branches: [ "main", "master" ]

jobs:
  # Job 1 : Qualité et Tests (S'exécute rapidement sans monter tout Docker)
  qualite-et-tests:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        working-directory: ./app # On se place dans le dossier du code sourc

    strategy:
      matrix:
        node-version: [18.x]

    steps:
    - name: Récupération du code
      uses: actions/checkout@v3

    - name: Installation de Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: './app/package-lock.json'

    - name: Installation des dépendances
      run: npm install

    - name: Analyse du code (Linting)
      run: npm run lint
      # Cela lancera la commande "eslint ." définie dans ton package.json

    - name: Tests Unitaires
      run: npm test
      # Cela lancera "jest". Assure-toi d'avoir des tests qui ne nécessitent pas la BDD  
      # ou d'utiliser des "mocks" pour cette étape.

  # Job 2 : Build Docker (S'exécute seulement si le Job 1 réussit)
  build-docker:
    needs: qualite-et-tests # Dépendance : on ne build pas si le code est mauvais
    runs-on: ubuntu-latest

    steps:
    - name: Récupération du code
      uses: actions/checkout@v3

    - name: Vérification de la configuration Docker Compose
      # L'option -f permet de spécifier le chemin vers le fichier docker-compose dans le dossier 'docker'
      run: docker compose -f docker-compose.yml config

    - name: Build et Démarrage des conteneurs
      # --build force la reconstruction
      # -d lance en arrière-plan detached
      run: docker compose -f docker-compose.yml up -d --build

    - name: Vérification que les conteneurs tournent
      run: docker compose -f docker-compose.yml ps
